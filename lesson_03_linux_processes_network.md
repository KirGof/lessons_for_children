# Урок 3 — Linux: процессы, сеть и переменные окружения

## Зачем это нужно

Сервер — это не статичная система. На нём постоянно что-то работает, падает, перезапускается, слушает сеть, общается с другими серверами. Инженер должен уметь: понять что сейчас происходит в системе, найти почему что-то не работает, разобраться с сетевыми подключениями и настроить окружение для программ. Без этих навыков отладка любой проблемы на сервере превращается в угадайку.

---

## Часть 1 — Процессы

### Что такое процесс

Процесс — это запущенная программа. Когда ты запускаешь `nginx` или `python app.py` — ОС создаёт процесс: выделяет память, назначает PID (уникальный числовой идентификатор), ставит в очередь планировщика.

Каждый процесс имеет:
- **PID** — уникальный идентификатор
- **PPID** — PID родительского процесса (тот кто его запустил)
- **Владельца** — пользователь от имени которого работает
- **Статус** — Running, Sleeping, Stopped, Zombie
- **Приоритет** — насколько часто CPU уделяет ему время

### Просмотр процессов

```bash
ps aux
```

Вывод:
```
USER    PID  %CPU %MEM    VSZ   RSS TTY  STAT START   TIME COMMAND
root      1   0.0  0.1  22560  1234 ?    Ss   10:00   0:01 /sbin/init
user   1234   0.5  1.2  45678  5678 pts/0 S+  10:05   0:00 bash
```

Расшифровка колонок:
- `USER` — владелец процесса
- `PID` — идентификатор
- `%CPU` — использование CPU
- `%MEM` — использование памяти
- `VSZ` — виртуальная память (KB)
- `RSS` — реальная память в RAM (KB)
- `STAT` — статус (S — sleeping, R — running, Z — zombie, D — ожидание I/O)
- `COMMAND` — команда которая запустила процесс

```bash
# Интерактивный мониторинг
top                  # Стандартный, есть везде
htop                 # Удобнее, нужно установить: sudo apt install htop

# Найти конкретный процесс
ps aux | grep nginx
pgrep nginx          # Вернёт только PID

# Дерево процессов — кто кого породил
pstree
pstree -p            # С PID
```

### Управление процессами

```bash
# Запуск в фоне
command &            # Запустить в фоне
jobs                 # Список фоновых задач
fg %1                # Вернуть задачу 1 на передний план
bg %1                # Отправить задачу 1 в фон
Ctrl+Z               # Приостановить текущий процесс
Ctrl+C               # Прервать текущий процесс

# Сигналы и kill
kill PID             # Отправить SIGTERM (вежливая просьба завершиться)
kill -9 PID          # Отправить SIGKILL (принудительное завершение)
kill -15 PID         # SIGTERM явно
killall nginx        # Убить все процессы с именем nginx

# Приоритет процессов (nice: от -20 до 19, меньше = выше приоритет)
nice -n 10 command   # Запустить с низким приоритетом
renice 5 -p PID      # Изменить приоритет запущенного процесса
```

### Systemd — управление сервисами

На современных Linux системах сервисы управляются через `systemd`:

```bash
# Управление сервисами
sudo systemctl start nginx        # Запустить
sudo systemctl stop nginx         # Остановить
sudo systemctl restart nginx      # Перезапустить
sudo systemctl reload nginx       # Перезагрузить конфиг без перезапуска
sudo systemctl status nginx       # Статус сервиса

# Автозапуск
sudo systemctl enable nginx       # Включить автозапуск при старте системы
sudo systemctl disable nginx      # Отключить автозапуск

# Просмотр логов сервиса
sudo journalctl -u nginx          # Все логи nginx
sudo journalctl -u nginx -f       # Следить за логами в реальном времени
sudo journalctl -u nginx --since "1 hour ago"
```

### Фоновые процессы — nohup и screen

Когда ты запускаешь программу в терминале и закрываешь терминал — программа получает сигнал SIGHUP и завершается. Чтобы этого избежать:

```bash
# nohup — игнорировать SIGHUP
nohup python app.py &
nohup python app.py > app.log 2>&1 &

# screen — виртуальные терминалы
sudo apt install screen
screen               # Создать новую сессию
Ctrl+A, D            # Отсоединиться (сессия продолжает работать)
screen -ls           # Список сессий
screen -r            # Подключиться к сессии

# tmux — современная альтернатива screen
sudo apt install tmux
tmux                 # Создать сессию
Ctrl+B, D            # Отсоединиться
tmux ls              # Список сессий
tmux attach          # Подключиться
```

---

## Часть 2 — Сеть в Linux

### Сетевые интерфейсы

```bash
# Посмотреть сетевые интерфейсы и IP адреса
ip addr show
ip a                 # Сокращение

# Старая команда (устаревшая но ещё встречается)
ifconfig

# Таблица маршрутизации — куда идут пакеты
ip route show
ip r
```

Вывод `ip a` выглядит так:
```
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP>
    link/ether 00:11:22:33:44:55
    inet 192.168.1.100/24 brd 192.168.1.255 scope global eth0
```

- `eth0` — имя интерфейса
- `192.168.1.100/24` — IP адрес и маска подсети
- `/24` означает что первые 24 бита — адрес сети (= маска 255.255.255.0)

### Диагностика сети

```bash
# Проверить доступность хоста
ping google.com
ping -c 4 google.com     # Отправить 4 пакета и остановиться

# Трассировка маршрута
traceroute google.com
tracepath google.com     # Альтернатива

# DNS запросы
nslookup github.com
dig github.com
dig github.com A         # Только A записи (IPv4)
dig github.com MX        # MX записи (почта)

# Проверить открытые порты и соединения
ss -tlnp                 # Что слушает на каких портах (современный способ)
netstat -tlnp            # Устаревший способ (sudo apt install net-tools)

# Расшифровка флагов ss:
# -t  TCP
# -l  listening (слушает, ожидает подключений)
# -n  числовые адреса (не резолвить имена)
# -p  показать процесс

# Скачать файл
curl -O https://example.com/file.zip
wget https://example.com/file.zip

# Сделать HTTP запрос
curl https://api.example.com/users
curl -X POST -H "Content-Type: application/json" \
     -d '{"name":"test"}' https://api.example.com/users
```

### Firewall — UFW

```bash
sudo ufw status              # Статус firewall
sudo ufw enable              # Включить
sudo ufw disable             # Выключить

sudo ufw allow 22            # Разрешить SSH
sudo ufw allow 80            # Разрешить HTTP
sudo ufw allow 443           # Разрешить HTTPS
sudo ufw deny 3306           # Запретить MySQL снаружи

sudo ufw allow from 192.168.1.0/24 to any port 5432  # PostgreSQL только из локалки
```

### SSH — работа с удалёнными серверами

SSH (Secure Shell) — протокол для безопасного подключения к удалённым серверам.

```bash
# Подключиться к серверу
ssh user@192.168.1.100
ssh user@server.example.com
ssh -p 2222 user@server.com      # Нестандартный порт

# Ключи SSH (безопаснее пароля)
ssh-keygen -t ed25519            # Создать пару ключей
# Публичный ключ: ~/.ssh/id_ed25519.pub  — кладётся на сервер
# Приватный ключ: ~/.ssh/id_ed25519      — никому не показывать!

# Скопировать публичный ключ на сервер
ssh-copy-id user@server.com

# Скопировать файлы через SSH
scp file.txt user@server:/home/user/    # Загрузить файл
scp user@server:/var/log/app.log ./     # Скачать файл
scp -r folder/ user@server:/home/user/ # Скопировать папку

# Туннелирование портов
ssh -L 8080:localhost:80 user@server   # Пробросить порт 80 сервера на локальный 8080
```

---

## Часть 3 — Переменные окружения

### Что это и зачем

Переменные окружения — это именованные значения которые доступны всем процессам в системе. Они используются чтобы:
- Передавать настройки программам без изменения кода
- Хранить пути, токены, конфигурацию
- Не хранить секреты (пароли, ключи) прямо в коде

```bash
# Посмотреть все переменные окружения
env
printenv

# Посмотреть конкретную переменную
echo $HOME
echo $PATH
echo $USER

# Важные переменные:
# PATH   — где искать программы
# HOME   — домашняя директория
# USER   — текущий пользователь
# SHELL  — текущий shell
# PWD    — текущая директория
```

### Установка переменных

```bash
# Временно — только для текущей сессии
export MY_VAR="hello"
export DATABASE_URL="postgres://user:pass@localhost/mydb"
export PORT=8080

# Использование переменной
echo $MY_VAR
echo "Port is: $PORT"

# Передать переменную только одной команде
MY_VAR=test ./my_program

# Постоянно — добавить в ~/.bashrc или ~/.profile
echo 'export MY_VAR="hello"' >> ~/.bashrc
source ~/.bashrc          # Применить изменения без перезапуска терминала
```

### PATH — как Linux находит программы

Когда ты пишешь `python3`, Linux ищет программу с таким именем в директориях из `$PATH`:

```bash
echo $PATH
# /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

# Добавить свою директорию в PATH
export PATH=$PATH:/home/user/scripts

# Найти где находится программа
which python3
which nginx
whereis nginx       # Показывает бинарник, конфиги, маны
```

### .env файлы — стандарт для проектов

В реальных проектах переменные окружения хранят в файле `.env`:

```bash
# .env файл
DATABASE_URL=postgres://user:password@localhost:5432/mydb
REDIS_URL=redis://localhost:6379
SECRET_KEY=mysecretkey123
PORT=8080
DEBUG=false
```

> ⚠️ `.env` файл НИКОГДА не коммитят в git. Всегда добавляй его в `.gitignore`.

```bash
# Загрузить переменные из .env в текущую сессию
export $(cat .env | xargs)

# Или использовать специальные инструменты
# Go, Python, Node — у каждого есть библиотеки для чтения .env
```

---

## Практические задания

### Задание 3.1 — Исследование процессов

```bash
# Выполни и изучи вывод
ps aux | head -20
ps aux | sort -k3 -rn | head -10    # Топ 10 по CPU
ps aux | sort -k4 -rn | head -10    # Топ 10 по памяти
pstree -p | head -30
```

**Что нужно сделать:**
1. Найди PID процесса `bash` командой `pgrep bash`
2. Найди его родителя (PPID) командой `ps -o ppid= -p <PID>`
3. Выясни что за процесс является родителем
4. Нарисуй цепочку: дедушка → папа → bash

---

### Задание 3.2 — Управление процессами

```bash
# Установи nginx для практики
sudo apt update
sudo apt install nginx -y

# Запусти и проверь статус
sudo systemctl start nginx
sudo systemctl status nginx

# Открой браузер или выполни
curl http://localhost
```

**Что нужно сделать:**
1. Убедись что nginx запущен и отвечает на `http://localhost`
2. Найди PID процесса nginx через `ps aux | grep nginx`
3. Останови nginx через `systemctl stop`
4. Убедись что теперь `curl http://localhost` возвращает ошибку
5. Включи автозапуск nginx: `sudo systemctl enable nginx`
6. Объясни разницу между `systemctl stop` и `kill -9 <PID>`

---

### Задание 3.3 — Сетевая диагностика

```bash
# Посмотри что слушает на каких портах
ss -tlnp
```

**Что нужно сделать:**
1. Запусти nginx если остановил
2. Выполни `ss -tlnp` и найди на каком порту слушает nginx
3. Выполни `curl -v http://localhost` и найди в выводе:
   - IP адрес к которому подключился
   - Версию HTTP протокола
   - Код ответа сервера
   - Заголовок `Server:`
4. Выполни `dig google.com` и найди:
   - IP адрес google.com
   - Время ответа DNS сервера (Query time)
   - Какой DNS сервер отвечал

---

### Задание 3.4 — Переменные окружения

Создай файл `~/projects/lesson3/app.sh`:

```bash
#!/bin/bash

# Скрипт должен читать конфиг из переменных окружения
# и выводить информацию о "приложении"

APP_NAME=${APP_NAME:-"MyApp"}        # Использовать значение по умолчанию если не задано
APP_PORT=${APP_PORT:-8080}
DATABASE_URL=${DATABASE_URL:-"не задан"}
DEBUG=${DEBUG:-false}

echo "=== Конфигурация приложения ==="
echo "Название:  $APP_NAME"
echo "Порт:      $APP_PORT"
echo "База:      $DATABASE_URL"
echo "Debug:     $DEBUG"
echo "Пользователь: $USER"
echo "Запущен:   $(date)"
```

**Что нужно сделать:**
1. Сделай скрипт исполняемым
2. Запусти без переменных — увидишь значения по умолчанию
3. Запусти с переменными:
   ```bash
   APP_NAME="TodoService" APP_PORT=3000 DEBUG=true ./app.sh
   ```
4. Создай файл `.env` рядом со скриптом с нужными значениями
5. Загрузи переменные из `.env` и снова запусти скрипт

---

### Задание 3.5 — Финальный проект урока

Напиши скрипт `~/projects/lesson3/monitor.sh` который:

1. Выводит топ-5 процессов по использованию CPU
2. Выводит топ-5 процессов по использованию памяти
3. Показывает все открытые TCP порты
4. Показывает текущие сетевые соединения (только ESTABLISHED)
5. Проверяет доступность `google.com` через ping (1 пакет) и выводит `OK` или `НЕДОСТУПЕН`

Каждый раздел должен иметь заголовок. Скрипт должен принимать необязательный аргумент `--save` и если он передан — сохранять вывод в файл `monitor_ДАТА.txt`.

**Подсказка для аргументов:**
```bash
if [ "$1" == "--save" ]; then
    # сохранить в файл
fi
```

---

## Шпаргалка

| Команда | Что делает |
|---------|-----------|
| `ps aux` | Все процессы |
| `kill -9 PID` | Принудительно убить процесс |
| `systemctl status` | Статус сервиса |
| `journalctl -u nginx -f` | Логи сервиса в реальном времени |
| `ss -tlnp` | Что слушает на каких портах |
| `ip a` | Сетевые интерфейсы и IP |
| `curl -v URL` | HTTP запрос с подробностями |
| `ssh user@host` | Подключиться к серверу |
| `export VAR=value` | Установить переменную окружения |
| `echo $VAR` | Вывести значение переменной |
| `env` | Все переменные окружения |

---

## Ресурсы для изучения

- **Процессы:** `man ps`, `man kill`, `man systemctl`
- **Сеть:** `man ss`, `man ip`, `man curl`, `man ssh`
- **Переменные:** `man bash` → раздел ENVIRONMENT
- **Практика:** `https://explainshell.com` — вставь любую команду и получи объяснение каждой части

---

## Как понять что урок пройден

- [ ] Понимаю что такое PID, PPID и дерево процессов
- [ ] Умею найти и убить любой процесс
- [ ] Умею управлять сервисами через systemctl
- [ ] Понимаю разницу между `kill` и `systemctl stop`
- [ ] Умею посмотреть что слушает на каких портах
- [ ] Могу подключиться к серверу по SSH
- [ ] Понимаю что такое переменные окружения и зачем они нужны
- [ ] Написал и запустил финальный скрипт `monitor.sh`

---

*Следующий урок: Git — контроль версий*
