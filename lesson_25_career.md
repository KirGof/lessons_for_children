# Урок 25 — Карьера: портфолио, System Design интервью, первая работа

## Зачем этот урок

Ты прошёл 24 урока и построил production-grade систему. Теперь — самый практичный вопрос: как превратить это в работу? Технические знания — необходимое условие, но не достаточное. Рекрутер смотрит на резюме за 30 секунд. Собеседование по System Design отсеивает большинство кандидатов. Портфолио либо открывает дверь, либо закрывает. Этот урок — о том как показать то что ты умеешь.

---

## Часть 1 — Оценка себя честно

### Что ты умеешь после курса

Пройдись по списку и честно оцени каждый пункт (0 — не делал, 1 — делал по инструкции, 2 — могу сам):

```
Linux и сети
[ ] Настроить сервер с нуля
[ ] Отладить сетевые проблемы (tcpdump, netstat, curl -v)
[ ] Написать systemd unit для своего сервиса
[ ] Настроить nginx как reverse proxy

Go
[ ] Написать HTTP API с нуля без фреймворка
[ ] Реализовать интерфейсы и применить их для тестируемости
[ ] Написать конкурентный код без гонок данных
[ ] Профилировать и оптимизировать производительность

PostgreSQL
[ ] Спроектировать схему с правильными индексами
[ ] Написать запрос с несколькими JOIN и объяснить план EXPLAIN
[ ] Настроить репликацию
[ ] Реализовать full-text search

Docker и Kubernetes
[ ] Написать Dockerfile с многоэтапной сборкой
[ ] Задеплоить приложение в K8s из нуля
[ ] Отладить упавший Pod (CrashLoopBackOff, OOMKilled)
[ ] Написать Helm Chart

CI/CD
[ ] Настроить pipeline с тестами и деплоем
[ ] Откатить деплой при инциденте
[ ] Автоматически создавать релизы

Мониторинг
[ ] Настроить Prometheus + Grafana с нуля
[ ] Написать PromQL запросы
[ ] Настроить алерты которые реально срабатывают
[ ] Найти утечку памяти через pprof

Архитектура
[ ] Объяснить разницу монолит vs микросервисы с трейдоффами
[ ] Спроектировать систему для 1M пользователей
[ ] Объяснить CAP теорему на примере
```

Всё что оценил на 1 — нужно переделать самостоятельно. Всё что на 0 — пройти заново.

---

## Часть 2 — Портфолио

### Что рекрутер и технический интервьюер хотят видеть

```
НЕ НУЖНО:                    НУЖНО:
- туториальные проекты       - реальные проблемы решённые тобой
- "hello world" API          - архитектурные решения с обоснованием
- пустые репозитории         - работающий код который можно запустить
- README без инструкции      - "git clone && docker compose up -d"
- один язык/технология       - стек который ты реально используешь
```

### Структура портфолио проекта

```
todo-system/
├── README.md            ← Самое важное
├── ARCHITECTURE.md      ← Почему именно так
├── PERFORMANCE.md       ← Что оптимизировал и как
└── ...

README.md должен содержать:
1. Что это и зачем
2. Технологический стек с обоснованием
3. Архитектурная диаграмма
4. Как запустить (буквально одна команда)
5. Как запустить тесты
6. Что интересного ты решил в этом проекте
```

### README который открывает двери

```markdown
# Todo Service

Production-grade REST API для управления задачами.

## Стек
- **Go 1.22** — бэкенд, выбор обусловлен производительностью и простотой деплоя
- **PostgreSQL 16** — основная БД с секционированием по дате и FTS
- **Redis** — кэш и rate limiting, снизил нагрузку на БД на 70%
- **Kafka** — асинхронная отправка уведомлений через Outbox Pattern
- **Kubernetes** — деплой с zero-downtime и HPA

## Архитектура

```
Client → API Gateway (Nginx) → todo-service (3 replicas)
                                     ↓
                               PostgreSQL (primary + replica)
                               Redis (cache + rate limiting)
                                     ↓
                               Kafka → notification-service
```

## Запуск

```bash
git clone https://github.com/username/todo-system
cd todo-system
docker compose up -d
# Приложение доступно на http://localhost:8080
```

## Интересные технические решения

**Outbox Pattern** — событие записывается в БД в той же транзакции что и изменение данных. Это гарантирует доставку события в Kafka даже при падении сервиса. Реализация: [link]

**Секционирование по месяцам** — при 10M задач запрос за последний месяц выполняется за 8ms вместо 3200ms. EXPLAIN ANALYZE показывает что сканируется только одна партиция.

**Read/Write Splitting** — SELECT запросы идут на PostgreSQL реплику, INSERT/UPDATE на primary. Это снизило нагрузку на primary на 65%.

## Нагрузочное тестирование

k6 тест на 100 concurrent пользователей:
- P50: 8ms
- P95: 42ms  
- RPS: 3200
- Error rate: 0.02%
```

### Что ещё добавить в портфолио

**Технический блог** — напиши 2-3 статьи о том что ты решил:
- "Как я настроил zero-downtime деплой в Kubernetes"
- "Outbox Pattern: гарантированная доставка событий"
- "PostgreSQL FTS vs Elasticsearch: когда что выбирать"

Платформы: Habr (русскоязычный), Dev.to, Medium, личный блог.

**Вклад в open source** — найти проект который используешь, исправить баг или улучшить документацию. Это показывает умение работать с чужим кодом.

---

## Часть 3 — Резюме

### Структура технического резюме

```
[Имя]
[email] [GitHub] [LinkedIn/Habr] [город]

ОПЫТ
[Если есть — даже стажировка или фриланс]

НАВЫКИ
Go, PostgreSQL, Docker, Kubernetes, Redis, Kafka
CI/CD: GitHub Actions, Terraform
Мониторинг: Prometheus, Grafana, Loki

ПРОЕКТЫ
Todo System — production-grade микросервисная система
  - Go, PostgreSQL, Redis, Kafka, Kubernetes, Terraform
  - Нагрузочное тестирование: 3200 RPS, P95 < 50ms
  - github.com/username/todo-system

ОБРАЗОВАНИЕ
[...]
```

### Что писать в описании навыков

```
Плохо:
"Знаю Go, PostgreSQL, Docker"

Хорошо:
"Go — написал production API, оптимизировал с 200ms до 8ms через профилировщик pprof"
"PostgreSQL — секционирование, репликация, full-text search, настройка индексов"
"Kubernetes — деплой с HPA, rolling updates, отладка инцидентов"
```

### Куда отправлять резюме

1. **HeadHunter** — основная площадка в России
2. **Habr Career** — IT специализированная
3. **LinkedIn** — международные компании
4. **Telegram каналы** — `@golang_jobs`, `@devops_jobs_ru`, `@kubernetes_jobs`
5. **Прямой контакт** — найди компанию которая тебе нравится, напиши напрямую в LinkedIn

---

## Часть 4 — System Design Interview

### Что это такое

На уровне Middle/Senior собеседование включает System Design — спроектируй систему за 45-60 минут. Нет правильного ответа, оценивается процесс думать, задавать вопросы, рассматривать трейдоффы.

### Структура ответа (всегда одинаковая)

```
1. Уточнить требования (5 минут)
   - Функциональные: что система делает
   - Нефункциональные: нагрузка, latency, availability

2. Оценить масштаб (2 минуты)
   - DAU (Daily Active Users)
   - QPS (Queries Per Second)
   - Объём данных

3. Высокоуровневый дизайн (10 минут)
   - Нарисовать компоненты
   - API эндпоинты

4. Детальный дизайн (20 минут)
   - Схема БД
   - Кэширование
   - Как масштабировать узкие места

5. Трейдоффы и что улучшить (5 минут)
   - Что ты бы сделал иначе
   - Что не успел проработать
```

### Пример: Спроектируй систему коротких ссылок (bit.ly)

**Шаг 1 — Уточняем требования:**
```
Q: Что должна делать система?
A: Создавать короткие ссылки и редиректить по ним

Q: Какая нагрузка?
A: 100M новых ссылок в день, 10B переходов в день

Q: Нужна ли аналитика кликов?
A: Да, базовая — страна, время

Q: Как долго живут ссылки?
A: По умолчанию вечно, можно задать TTL
```

**Шаг 2 — Оцениваем масштаб:**
```
Записей: 100M/день = 1200/сек (write QPS)
Переходов: 10B/день = 115K/сек (read QPS)
Соотношение read:write = ~100:1

Объём хранилища:
100M ссылок/день × 365 дней × 5 лет = 182B ссылок
Одна запись: 100 байт (url, short_code, created_at, user_id)
182B × 100 байт = ~18 TB
```

**Шаг 3 — Высокоуровневый дизайн:**
```
Client → Load Balancer → [URL Service] → PostgreSQL
                               ↓
                             Redis Cache
                               ↓
                         [Analytics Service] → Kafka → ClickHouse
```

**Шаг 4 — Детальный дизайн:**
```sql
-- Схема
CREATE TABLE urls (
    id         BIGSERIAL PRIMARY KEY,
    short_code VARCHAR(8) UNIQUE NOT NULL,
    long_url   TEXT NOT NULL,
    user_id    BIGINT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE INDEX idx_urls_short_code ON urls (short_code);

-- Генерация short_code
-- Вариант 1: Base62(auto-increment id)
-- id=1 → "000001", id=1000000 → "4c92"
-- Проблема: предсказуемо, можно перебрать

-- Вариант 2: random 6-8 символов + проверка коллизии
-- Проблема: медленнее из-за проверок

-- Вариант 3: MD5(url)[:8] + проверка коллизии
-- Детерминировано для одного URL
```

```go
// Редирект — критичный путь, должен быть максимально быстрым
func (h *Handler) redirect(w http.ResponseWriter, r *http.Request) {
    shortCode := r.PathValue("code")

    // 1. Смотреть в Redis (TTL = 24 часа для горячих ссылок)
    longURL, err := h.cache.Get(r.Context(), shortCode)
    if err == nil {
        // Cache hit — редиректим мгновенно
        publishClickEvent(shortCode, r)    // async
        http.Redirect(w, r, longURL, http.StatusMovedPermanently)
        return
    }

    // 2. Cache miss — идём в PostgreSQL
    longURL, err = h.storage.GetURL(r.Context(), shortCode)
    if err != nil {
        http.NotFound(w, r)
        return
    }

    // 3. Сохранить в кэш
    h.cache.Set(r.Context(), shortCode, longURL, 24*time.Hour)

    publishClickEvent(shortCode, r)
    http.Redirect(w, r, longURL, http.StatusMovedPermanently)
}
```

**Шаг 5 — Трейдоффы:**
```
Что не проработал:
- Как удалять истёкшие ссылки (pg_cron + батчевое удаление)
- Защита от злоупотреблений (rate limiting по IP)
- Custom aliases (vanity URLs)
- Аналитика в реальном времени (ClickHouse + Kafka)

Трейдоффы:
- PostgreSQL vs Cassandra: выбрал PG потому что strong consistency
  важнее для записи, а чтение кэшируется в Redis
- 301 vs 302: 301 кэшируется браузером, снижает нагрузку,
  но теряем аналитику кликов
```

### Типичные задачи System Design

Подготовься к этим сценариям (изучи каждый):

1. **URL Shortener** — bit.ly (разобрали выше)
2. **Instagram** — хранение и раздача фото
3. **Twitter Feed** — лента пользователя
4. **YouTube** — видеохостинг
5. **Distributed Cache** — Redis-подобная система
6. **Rate Limiter** — алгоритмы (token bucket, sliding window)
7. **Notification Service** — отправка миллионов push/email
8. **Search Engine** — поисковый индекс
9. **Ride-sharing** — Uber/Яндекс.Такси
10. **Chat System** — WhatsApp/Telegram

---

## Часть 5 — Техническое интервью: алгоритмы

Junior/Middle DevOps/Backend позиции часто проверяют базовые алгоритмы. Не LeetCode Hard, но знать нужно.

### Что нужно знать

```go
// Структуры данных
// - Массивы/слайсы: операции O(1) доступ, O(n) поиск
// - HashMap: O(1) вставка/поиск
// - Стек/Очередь: LIFO/FIFO
// - Связный список
// - Бинарное дерево

// Алгоритмы
// - Binary Search: O(log n)
// - Two Pointers
// - Sliding Window
// - BFS/DFS для графов
// - Базовые сортировки (понимать, не реализовывать)

// Примеры задач уровня Junior/Middle:
// - Найти дубликаты в массиве (HashMap)
// - Reverse строки/слайса
// - FizzBuzz (не шутка, проверяют)
// - Palindrome check
// - Анаграммы
// - Top K элементов
// - Merge sorted arrays
```

### Формат ответа на алгоритмическую задачу

```
1. Понять задачу — повторить своими словами
2. Уточнить: размер данных, edge cases
3. Brute force решение вслух
4. Оптимизация
5. Написать код
6. Протестировать на примерах вслух
```

---

## Часть 6 — Поведенческие вопросы

### STAR метод

```
S — Situation: контекст
T — Task: задача
A — Action: что ты сделал
R — Result: результат

Пример:
Q: "Расскажи о сложном техническом решении которое принял"

S: "В проекте todo-service нужно было гарантировать что события
    попадают в Kafka даже при падении сервиса"
T: "Обычный вызов kafka.Publish мог потерять событие если сервис
    упадёт после записи в БД но до отправки"
A: "Реализовал Outbox Pattern — событие пишется в таблицу outbox
    в той же транзакции что и изменение данных. Отдельный воркер
    читает outbox и публикует в Kafka. При падении — воркер
    догонит при следующем старте"
R: "Нулевая потеря событий в течение 3 месяцев нагрузочного
    тестирования. Добавил метрику outbox_pending_count в Prometheus"
```

### Топ вопросов и как отвечать

```
Q: "Почему Go/PostgreSQL/Kubernetes?"
A: Конкретные причины, не "потому что популярно"
   Go: статическая типизация, простота, быстрый старт контейнера
   PostgreSQL: ACID, хорошая экосистема, JSON support, FTS из коробки

Q: "Расскажи об инциденте который ты разрешил"
A: Используй STAR. Важно: что ты ЛИЧНО сделал, что узнал

Q: "Как ты остаёшься в курсе новинок?"
A: Конкретные источники: блоги компаний, подкасты, changelog Go

Q: "Где видишь себя через 3 года?"
A: Честно и конкретно. "Хочу глубоко разбираться в distributed systems
   и решать задачи масштабирования" лучше чем "стать сениором"

Q: "Есть ли вопросы к нам?"
A: ВСЕГДА задавай вопросы. Подготовь 3-5:
   - "Как выглядит типичный инцидент и как его обрабатываете?"
   - "Какой стек используете в производстве?"
   - "Как проходит онбординг нового инженера?"
   - "Что считаете главным вызовом команды сейчас?"
```

---

## Практические задания

### Задание 25.1 — Аудит портфолио

Пройдись по репозиторию `todo-service` и сделай чеклист:

```
[ ] README.md объясняет проект за 30 секунд
[ ] Есть архитектурная диаграмма (даже ASCII)
[ ] git clone && docker compose up -d работает на чистой машине
[ ] Все тесты запускаются через make test
[ ] Нет секретов в git истории
[ ] Код читаемый — переменные говорящие, функции небольшие
[ ] ARCHITECTURE.md объясняет почему именно такой стек
[ ] PERFORMANCE.md показывает результаты нагрузочного тестирования
[ ] Есть теги версий (v0.1.0 ... v2.4.0)
```

Исправь всё что не отмечено.

---

### Задание 25.2 — Написать статью

Напиши техническую статью об одном из решений которые ты реализовал. Минимум 1000 слов. Структура:

```
1. Проблема которую я решал (конкретная, с числами)
2. Что рассматривал (варианты и трейдоффы)
3. Что выбрал и почему
4. Как реализовал (ключевые куски кода)
5. Результат (до/после, числа)
6. Что бы сделал иначе
```

Опубликуй на Habr или Dev.to. Ссылку добавь в GitHub profile.

---

### Задание 25.3 — Три System Design за неделю

Разбери три задачи самостоятельно, запиши решения в `system-design/`:

```
system-design/
├── url-shortener.md
├── notification-service.md
└── twitter-feed.md
```

Каждый файл: требования → оценка масштаба → схема → БД → кэш → масштабирование → трейдоффы.

Затем попроси кого-нибудь (или AI) сыграть роль интервьюера — объясни решение вслух за 45 минут.

---

### Задание 25.4 — Резюме

Напиши резюме и дай на ревью 2-3 людям:

1. Техническому другу — правильно ли описаны навыки
2. Рекрутеру (можно через LinkedIn попросить фидбек)
3. Если есть возможность — человеку который нанимает разработчиков

Ключевые вопросы:
- Понятно ли за 30 секунд что ты умеешь?
- Есть ли конкретные числа и результаты?
- Хочется ли пригласить на собеседование?

---

### Задание 25.5 — Финальный проект курса

Это не код. Это план.

Создай файл `MY_CAREER_PLAN.md`:

```markdown
# Карьерный план

## Текущий уровень
[Честная оценка по чеклисту из урока]

## Цель через 6 месяцев
[Конкретная должность, компания типа, зарплата]

## Что нужно сделать

### Неделя 1-2: Портфолио
- [ ] README всех проектов
- [ ] Написать статью на Habr
- [ ] Обновить GitHub profile

### Неделя 3-4: Подготовка к интервью
- [ ] 20 задач LeetCode Easy/Medium
- [ ] 5 System Design разборов
- [ ] Записать себя на видео как отвечаю на вопросы

### Месяц 2: Активный поиск
- [ ] Отправить 20 резюме
- [ ] 5 первичных собеседований
- [ ] Разобрать каждый отказ

### Месяц 3-6: Итерация
- [ ] Анализировать обратную связь
- [ ] Заполнять пробелы в знаниях
- [ ] Не останавливаться

## Компании в приоритете
[Список из 10 компаний которые тебе интересны]

## Что делать если не берут
1. Попросить обратную связь (большинство откажет, но некоторые дадут)
2. Найти конкретный пробел
3. Закрыть пробел (1-2 недели)
4. Повторить
```

---

## Итог всего курса

25 уроков, одна система, один путь.

Ты начал с вопроса "что такое процесс в Linux" и пришёл к "как спроектировать систему для 10M пользователей".

По пути ты построил:
- Go REST API с JWT аутентификацией
- PostgreSQL с репликацией, партиционированием, FTS
- Docker образ < 20MB
- Kubernetes деплой с HPA и zero-downtime
- CI/CD который тестирует и деплоит автоматически
- Prometheus + Grafana с SLO и error budget
- Redis кэш и rate limiting
- Kafka с Outbox Pattern
- gRPC интерфейс
- Terraform для облачной инфраструктуры
- Helm Chart для окружений
- HashiCorp Vault для секретов
- Chaos Engineering тесты
- Disaster Recovery план

Это не учебный проект. Это то что ты теперь умеешь.

Дальше — не курсы. Дальше — реальные задачи, реальные инциденты, реальная команда.

Удачи.

---

## Ресурсы для подготовки к интервью

- **System Design:** `https://github.com/donnemartin/system-design-primer` — лучший бесплатный ресурс
- **Книга:** "System Design Interview" — Alex Xu — читать обязательно
- **Алгоритмы:** `https://neetcode.io` — лучше чем LeetCode для подготовки
- **Поведенческие:** `https://www.levels.fyi` — зарплаты и отзывы о компаниях
- **Habr Career:** `https://career.habr.com` — вакансии и статьи о карьере
- **Подкаст:** "Podlodka Crew" — русскоязычный IT подкаст
- **YouTube:** "ByteByteGo" — System Design разборы

---

## Как понять что урок пройден

- [ ] Портфолио: README понятен, docker compose up работает
- [ ] Написана и опубликована техническая статья
- [ ] Разобраны 3 System Design задачи письменно
- [ ] Резюме прошло ревью у 2+ человек
- [ ] Есть конкретный карьерный план с датами
- [ ] Отправлены первые 5 резюме
